# System organization
## Repository
We set up **continuous integration (CI)** pipeline automation in the repository using GitLab ylm. 
This allowed us to automatically make sure all our tests passed before any integrations
were made in the project. No failed pipelines can be merged in the repository.

Furthermore we restricted all developers from merging their own code. That meant that for every
merge made there had to be a person reviewing the code alongside the CI verification.

## Software Structure
We have **layered our system extensively** to make sure that components are individually 
replaceable and updatable. This has benefited us greatly in the continuous (agile) development 
process. 

The software needs to be continuously updated according to ever new standards and having 
our software separated into **smaller components that are loosely coupled** makes the complexity 
of the changes less drastic.

Furthermore this has made our system more **manageable** for a group our size and allowed for 
**easier distribution of workload**.

## Work distribution
Having our project well layered allowed us to distribute work between team members in whichever
section of the project they deemed fit, without having much of an impact on others.

# Design patterns in system
1. Layered Architecture\
As mentioned in the software structure section, the system is divided into layers. The image below
depicts the current layering
[!image]()
2. Singleton pattern \
Interface communicator class
3. Factory pattern \
for example data layer (parent class data)
4. Facade pattern \
for example auth model
# Refactor possibilities
1. **The data storage** \
The data storage choice is definitely not ideal for scalability and the amount 
of data generated by the software. Ideally we would move to any type of SQL storage. This
would require only a few changes to the fetch/update methods in the data layer parent class. 

2. **The interface data adapter** \
Ideally we would have a separate component that adapts data to the front ends requirements. 
Currently we have methods for this in each logic layer. However as of right now the required 
data in the front end is pretty over complicated with cross references between our models making 
it quite a leap to create a data adapter.

